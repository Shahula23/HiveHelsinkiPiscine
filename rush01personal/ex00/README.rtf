{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf600
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red199\green200\blue201;\red20\green22\blue25;}
{\*\expandedcolortbl;;\cssrgb\c81961\c82353\c82745;\cssrgb\c10196\c11373\c12941;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{none\}}{\leveltext\leveltemplateid1\'00;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww16840\viewh13320\viewkind0
\deftab720
\pard\pardeftab720\sl340\partightenfactor0

\f0\fs36 \cf2 \cb3 \expnd0\expndtw0\kerning0
Store possible combinations somewhere to access during checks. \
\pard\pardeftab720\sl340\partightenfactor0
\cf2 \cb1 \
\pard\pardeftab720\sl340\partightenfactor0
\cf2 \cb3 Check the clues\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl340\partightenfactor0
\ls1\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
If 4, then we know we can fill the row with 1234\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 		\expnd0\expndtw0\kerning0
If 1, then number in the cell next to it is 4\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 		As we go through the grid. w\expnd0\expndtw0\kerning0
e need to also check if the field is already filled. If it is, skip the cell.\
\pard\pardeftab720\sl340\partightenfactor0
\cf2 \cb1 \
\pard\pardeftab720\sl340\partightenfactor0
\cf2 \cb3 1.Go through the cells until we find an empty one\cb1 \
\cb3 2.Find out in which row it is\cb1 \
\cb3 3.Check neighbouring cells to eliminate impossible combinations. Select a possible combination from combination store.\cb1 \
\cb3 4.Check this combination for both sides of the row\cb1 \
\cb3 5.And check if number are not repeated in rows and columns (check only for previous rows that are filled)\
\pard\pardeftab720\sl340\partightenfactor0
\cf2 \cb3 6.Save the position for backtracking (place in our grid) \cf2 \cb1 \
\pard\pardeftab720\sl340\partightenfactor0
\cf2 \cb3 (if we are out of combinations then display error). If there are still combinations to be checked in a row, then go back and check them. Any used combinations in the row are stored somewhere so they aren\'92t used again for this specific row.\cb1 \
\cb3 8.Go to next row\cb1 \
\cb3 9.Repeat\
\pard\pardeftab720\sl340\partightenfactor0
\cf2 \cb1 \
\pard\pardeftab720\sl340\partightenfactor0
\cf2 \cb3 If we good with rows and the grid is filled, then we check columns for valid combinations.\cb1 \
\cb3 If there are errors in columns then go back to previous check point. Repeat row process until both row and column conditions are satisfied. \
\
If we reach the end and grid is valid then we print the grid.\
\
Not sure how malloc and free would be implemented with this problem. We know that malloc is used to allocate things to a place in memory and returns a pointer to where it is saved. We know it is dynamic. Free is used to deallocate that memory. Not sure where this would be used however. Perhaps when the program is checking each row?}